#pragma once
#include <iostream>
#include "../util/ThreadPool.h"
//#include "Node.h"
//#include "State.h"
//#include "Bulid_Tree.h"
//#include "Save_load.h"
using namespace std;
std::condition_variable cfvdumpwait;
mutex cfvmtx;
threadpool cfvpool(100, &cfvdumpwait);
inline float findmax(float a[], int len) {
	int idx = 0;
	float maxval = a[0];
	for (int i = 1; i < len; i++)
		if (a[i] > maxval)
			maxval = a[i];
	return maxval;
}
void getnode_cfv_river(subgame_node* privatenode[1128], double range[1128], Searchstate& state, int len, double actionicfvs1[1128], int expoliti, int clusters[1128],int mycard, int cardindex_to_id[1128]) {
	if (state.is_terminal()) {
		//cout << ++static_terminal << endl;
		if (state.betting_stage == 5) {
			for (int i = 0; i < len; i++) {
				if (state.player_i_index == expoliti)
					actionicfvs1[i] = (state.table.players[expoliti ^ 1].initial_chips - state.table.players[expoliti ^ 1].n_chips);
				else
					actionicfvs1[i] = -(state.table.players[expoliti].initial_chips - state.table.players[expoliti].n_chips);
			}
			return;
		}
		assert(len == 1081); 
		int selfc = expoliti ^ 1;
		bool vis[52] = { false };
		assert(clusters[mycard] != -1);
		int idx1 = cardindex_to_id[mycard];
		int c1 = idx1 / 52, c2 = idx1 % 52;
		vis[c1] = vis[c2] = true;
		for (int j = 0; j < len; j++) {
			if (mycard == j) {
				actionicfvs1[j] = 0;
				continue;
			}
			int idx2 = cardindex_to_id[j];
			int d1 = idx2 / 52, d2 = idx2 % 52;
			if (!vis[d1] && !vis[d2] && range[j] > 0) {
				assert(clusters[j] != -1);
				if (clusters[mycard] > clusters[j])
					actionicfvs1[j] = -state.table.total_pot * 0.5;
				else if (clusters[mycard] < clusters[j])
					actionicfvs1[j] = state.table.total_pot * 0.5;
				else
					actionicfvs1[j] = 0;
			}
			else
				actionicfvs1[j] = 0;
		}
		return;
	}
	int ph = state.player_i_index;
	subgame_node* tempprivatenode[1081];
	unsigned char lactions[12];
	int laction_len = state.legal_actions(lactions);
	assert(laction_len != 0);
	double cfv[8][1081];
	for (int i = 0; i < laction_len; i++) {
		Searchstate newstate = state;
		bool is_chance = newstate.take_action(lactions[i]);
		for (int j = 0; j < len; j++)
			tempprivatenode[j] = privatenode[j]->actions + i;
		if (state.player_i_index != expoliti) {
			double actionipro[1081];
			for (int j = 0; j < len; j++) {
				actionipro[j] = 0;
				if (range[j] > 0.0000000001) {
					double tmp = calculate_strategy(privatenode[j]->ave_strategy, privatenode[j]->action_len, i);
					actionipro[j] = range[j];
					range[j] *= tmp;
				}
			}
			getnode_cfv_river(tempprivatenode, range, newstate, len, cfv[i], expoliti, clusters, mycard, cardindex_to_id);
			for (int j = 0; j < len; j++)
				range[j] = actionipro[j];
		}
		else
			getnode_cfv_river(tempprivatenode, range, newstate, len, cfv[i], expoliti, clusters, mycard, cardindex_to_id);
	}
	if (state.player_i_index == expoliti) {
		double cfvs[12];
		int selfc = expoliti ^ 1;
		memset(cfvs, 0, sizeof cfvs);
		double ans = range[0];
		for (int i = 1; i < len; i++)
			ans += range[i];
		for (int j = 0; j < len; j++)
			if (range[j] > 0.00000000001) {
				double temp = range[j] / ans;
				for (int k = 0; k < privatenode[j]->action_len; k++)
					cfvs[k] += temp * cfv[k][j];
			}
		int index = 0;
		for (int k = 1; k < laction_len; k++)
			if (cfvs[index] < cfvs[k])
				index = k;
		for (int j = 0; j < len; j++)
			actionicfvs1[j] = cfv[index][j];
	}
	else
		for (int j = 0; j < len; j++) {
			if (range[j] > 0.00000000001) {
				double sigma[12];
				calculate_strategy(privatenode[j]->ave_strategy, privatenode[j]->action_len, sigma);
				double val = 0;
				for (int i = 0; i < privatenode[j]->action_len; i++)
					val += cfv[i][j] * sigma[i];
				actionicfvs1[j] = val;
			}
			else
				actionicfvs1[j] = 0;
		}
}
void getnode_cfv_turn(subgame_node* privatenode[2652], Searchstate& state, double range[1128], int cardindex_to_id[1128], int len, double actionicfvs1[1128], int expoliti, int mycard,int to_cluster[1128][52]) {//蓝图策略树构建
	if (state.is_terminal()) {
		//cout << ++static_terminal << endl;
		if (state.betting_stage == 5) {
			for (int i = 0; i < len; i++) {
				if (state.player_i_index == expoliti)
					actionicfvs1[i] = (state.table.players[expoliti ^ 1].initial_chips - state.table.players[expoliti ^ 1].n_chips);
				else
					actionicfvs1[i] = -(state.table.players[expoliti].initial_chips - state.table.players[expoliti].n_chips);
			}
			return;
		}
		if (len > 1000) {
			bool vis[52] = { false };
			int idx1 = cardindex_to_id[mycard];
			int c1 = idx1 / 52, c2 = idx1 % 52;
			vis[c1] = vis[c2] = true;
			for (int i = 0; i < len; i++) {
				int idx2 = cardindex_to_id[i];
				int cc1 = idx2 / 52, cc2 = idx2 % 52;
				if (vis[cc1] || vis[cc2] || range[i] == 0) {
					actionicfvs1[i] = 0;
					continue;
				}
				int id0 = 0, id1 = 0, id2 = 0;
				for (int j = 0; j < 52; j++) {
					if (to_cluster[i][j] == -1 || to_cluster[mycard][j] == -1)
						continue;
					if (to_cluster[mycard][j] > to_cluster[i][j])
						id0++;
					else if (to_cluster[mycard][j] < to_cluster[i][j])
						id1++;
					else
						id2++;
				}
				assert(id0 + id1 + id2 == 44);
				double winrate = (id0 + id2 / 2.0) / 44;	//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
				actionicfvs1[i] = (0.5 - winrate) * state.table.total_pot;//期望赢得筹码-投入的筹码 = 期望收益
			}
		}
		else {
			for (int i = 0; i < len; i++) {
				if (range[i] == 0) 
					actionicfvs1[i] = 0;
				else {
					if (mycard > i)
						actionicfvs1[i] = -state.table.total_pot * 0.5;
					else if (mycard < i)
						actionicfvs1[i] = state.table.total_pot * 0.5;
					else
						actionicfvs1[i] = 0;
				}
			}
		}
		return;
	}
	int ph = state.player_i_index;
	subgame_node* tempprivatenode[1128];
	unsigned char lactions[12];
	int laction_len = state.legal_actions(lactions);
	assert(laction_len != 0);
	double cfv[8][1128];
	memset(cfv, 0, sizeof cfv);
	for (int i = 0; i < laction_len; i++) {
		Searchstate newstate = state;
		bool is_chance = newstate.take_action(lactions[i]);
		double newrange[1128];
		if (state.player_i_index != expoliti) {
			for (int j = 0; j < len; j++) {
				if (range[j] > 0){
					double tmp;
					if (privatenode[j]->ave_strategy[i])
						tmp = calculate_strategy(privatenode[j]->ave_strategy, privatenode[j]->action_len, i);
					else
						tmp = calculate_strategy(privatenode[j]->regret, privatenode[j]->action_len, i);
					newrange[j] = range[j] * tmp;
				}
			}
		}
		else {
			for (int j = 0; j < len; j++) 
				newrange[j] = range[j];
		}
		if (is_chance) {

			double temprange[1000];
			double tempactionicfv1[1000];

			subgame_node* tempprivatenode2[1000];
			for (int k = 0; k < 1000; k++)
				tempprivatenode2[k] = privatenode[0]->actions[i].actions + k;
			bool vis[52] = { false };
			vis[cardindex_to_id[mycard] / 52] = vis[cardindex_to_id[mycard] % 52] = true;
			int cnt = 0;
			for (int j = 0; j < 52; j++) {
				if (to_cluster[mycard][j] != -1) {
					cnt++;
					memset(temprange, 0, sizeof(temprange));
					double tot = 0;
					for (int k = 0; k < len; k++) {
						int idx1 = cardindex_to_id[k] / 52, idx2 = cardindex_to_id[k] % 52;
						if (!vis[idx1] && !vis[idx2] && newrange[k] > 0) {
							temprange[to_cluster[k][j]] += newrange[k];
							tot += newrange[k];
						}
					}
					getnode_cfv_turn(tempprivatenode2, newstate, temprange, cardindex_to_id, 1000, tempactionicfv1, expoliti, j, to_cluster);
					for (int k = 0; k < len; k++)
						if (tempactionicfv1[k] > 0)
							cfv[i][k] += tempactionicfv1[to_cluster[k][j]];
				}
			}
			assert(cnt == 46);
			for (int k = 0; k < len; k++)
				cfv[i][k] /= 46;
		}
		else {
			for (int j = 0; j < len; j++)
				tempprivatenode[j] = privatenode[j]->actions + i;
			getnode_cfv_turn(tempprivatenode, newstate, newrange, cardindex_to_id, len, cfv[i], expoliti, mycard, to_cluster);
		}
	}
	if (state.player_i_index == expoliti) {
		double cfvs[12];
		int selfc = expoliti ^ 1;
		memset(cfvs, 0, sizeof cfvs);
		double ans = range[0];
		for (int i = 1; i < len; i++)
			ans += range[i];
		for (int j = 0; j < len; j++)
			if (range[j] > 0.00000000001) {
				double temp = range[j] / ans;
				for (int k = 0; k < privatenode[j]->action_len; k++)
					cfvs[k] += temp * cfv[k][j];
			}
		int index = 0;
		for (int k = 1; k < laction_len; k++)
			if (cfvs[index] < cfvs[k])
				index = k;
		for (int j = 0; j < len; j++){
			actionicfvs1[j] = cfv[index][j];
			assert(actionicfvs1[j] < 20001);
		}
	}
	else
		for (int j = 0; j < len; j++) {
			if (range[j] > 0.00000000001) {
				double sigma[12];
				if (privatenode[j]->ave_strategy[0] || privatenode[j]->ave_strategy[1])
					calculate_strategy(privatenode[j]->ave_strategy, privatenode[j]->action_len, sigma);
				else
					calculate_strategy(privatenode[j]->regret, privatenode[j]->action_len, sigma);
				double val = 0;
				for (int i = 0; i < privatenode[j]->action_len; i++)
					val += cfv[i][j] * sigma[i];
				actionicfvs1[j] = val;
			}
			else
				actionicfvs1[j] = 0;
			assert(actionicfvs1[j] < 20001);
		}
}
/// index to id : 1326 -> 2652
/// id to index : 2652 -> 1326
void thread_cfv_river(subgame_node* privatenode[1128], double range[2652], Searchstate state, int len, int expoliti, int clusters[1081], int mycard, int cardindex_to_id[1128],double* exploitval) {
	double actionicfvs1[1081];
	bool vis[52] = { false };
	int idx1 = cardindex_to_id[mycard];
	int c1 = idx1 / 52, c2 = idx1 % 52;
	double tot = 0;
	vis[c1] = vis[c2] = true;
	double ranget[1081];
	memset(ranget, 0, sizeof ranget);
	for (int i = 0; i < 1081; i++) {
		int idx2 = cardindex_to_id[i];
		int r1 = idx2 / 52, r2 = idx2 % 52;
		if (!vis[r1] && !vis[r2] && range[r1 * 52 + r2] != 0) {
			assert(range[r1 * 52 + r2] > 0);
			assert(ranget[i] == 0);
			ranget[i] = range[r1 * 52 + r2];
			tot += ranget[i];
		}
	}
	assert(tot > 0);
	getnode_cfv_river(privatenode, ranget, state, len, actionicfvs1, expoliti, clusters, mycard, cardindex_to_id);
	for (int i = 0; i < 1081; i++)
		*exploitval += ranget[i] * actionicfvs1[i];
	*exploitval /= tot;
	return;
}
void thread_cfv_turn(subgame_node* privatenode[1128], double range[2652], Searchstate state, int len, int expoliti, int to_cluster[1128][52], int mycard, int cardindex_to_id[1128], double* exploitval) {
	double actionicfvs1[1128];
	bool vis[52] = { false };
	int idx1 = cardindex_to_id[mycard];
	int c1 = idx1 / 52, c2 = idx1 % 52;
	double tot = 0;
	vis[c1] = vis[c2] = true;
	double ranget[1128];
	memset(ranget, 0, sizeof ranget);
	for (int i = 0; i < 1128; i++) {
		int idx2 = cardindex_to_id[i];
		int r1 = idx2 / 52, r2 = idx2 % 52;
		if (!vis[r1] && !vis[r2] && range[r1 * 52 + r2] != 0) {
			assert(range[r1 * 52 + r2] > 0);
			assert(ranget[i] == 0);
			ranget[i] = range[r1 * 52 + r2];
			tot += ranget[i];
		}
	}
	assert(tot > 0);
	getnode_cfv_turn(privatenode, state, ranget, cardindex_to_id, len, actionicfvs1, expoliti, mycard, to_cluster);
	for (int i = 0; i < 1128; i++)
		*exploitval += ranget[i] * actionicfvs1[i];
	*exploitval /= tot;
	return;
}
double getcfvturn(subgame_node* privateroot, Searchstate state, double range0[2652], double range1[2652], unsigned char comm[], int exi, int cardindex_to_id[1128], int to_cluster[1128][52]) {
	subgame_node* privatenode[1128];
	for (int i = 0; i < privateroot->action_len; i++)
		privatenode[i] = privateroot->actions + i;
	
	assert(privateroot->action_len == 1128);
	double exploitval[1128];
	memset(exploitval, 0, sizeof exploitval);
	double normv = 0;
	double* exploiting_range = (exi == 0 ? range0 : range1);
	double* exploitd_range = (exi == 1 ? range1 : range0);
	std::unique_lock<mutex> lck(cfvmtx);
	for (int k = 0; k < 1128; k++) {
		if (exploiting_range[cardindex_to_id[k]] <= 0) {
			exploitval[k] = 0;
			continue;
		}
		normv += exploiting_range[cardindex_to_id[k]];
		cfvpool.commit(thread_cfv_turn, privatenode, exploitd_range, state, 1128, exi, to_cluster, k, cardindex_to_id, &exploitval[k]);
	}
	cfvdumpwait.wait(lck);
	while (cfvpool.acttaskNum.load() != 0)
		sleep(1);
	double ans = 0;
	for (int i = 0; i < 1128; i++)
		if (exploitval[i]) {
			ans += exploiting_range[cardindex_to_id[i]] * exploitval[i];
		}
	return ans / normv;
}
double getcfv(subgame_node* privateroot, Searchstate state, double range0[2652], double range1[2652],unsigned char comm[],int exi, int clusters[1081], int cardindex_to_id[1128]) {	//bulid whole game tree
	subgame_node* privatenode[1081];
	for (int i = 0; i < privateroot->action_len; i++)
		privatenode[i] = privateroot->actions + i;
	{
		assert(privateroot->action_len == 1081);
		double exploitval[1081];
		memset(exploitval, 0, sizeof exploitval);
		double normv = 0;
		double* exploiting_range = (exi == 0 ? range0 : range1);
		double* exploitd_range = (exi == 1 ? range1 : range0);
		std::unique_lock<mutex> lck(cfvmtx);
		for (int k = 0; k < 1081; k++) {
			if (exploiting_range[cardindex_to_id[k]] <= 0) {
				exploitval[k] = 0;
				continue;
			}
			//assert(cardid_to_index[cardindex_to_id[k]] == k);
			normv += exploiting_range[cardindex_to_id[k]];
			cfvpool.commit(thread_cfv_river, privatenode, exploitd_range, state, 1081, exi, clusters, k, cardindex_to_id, &exploitval[k]);
		}
		cfvdumpwait.wait(lck);
		while (cfvpool.acttaskNum.load() != 0)
			sleep(1);
		double ans = 0;
		for (int i = 0; i < 1081; i++)
			if (exploitval[i]) {
				ans += exploiting_range[cardindex_to_id[i]] * exploitval[i];
			}
		return ans / normv;
	}
}

void getnode_cfv_holdem(strategy_node* privatenode[2652], Pokerstate& state, double range[2652], double actionicfvs1[2652],unsigned char communitycards[5], int expoliti, int mycard, int endstage) {//蓝图策略树构建
	if (state.is_terminal()) {
		if (state.betting_stage == 5) {
			for (int i = 0; i < total_cards; i++) {
				for (int j = i + 1; j < total_cards; j++)
					if (range[i * 52 + j] > 0) {
						if (state.player_i_index == expoliti)
							actionicfvs1[i * 52 + j] = (state.table.players[expoliti ^ 1].initial_chips - state.table.players[expoliti ^ 1].n_chips);
						else
							actionicfvs1[i * 52 + j] = -(state.table.players[expoliti].initial_chips - state.table.players[expoliti].n_chips);
					}
					else
						actionicfvs1[i * 52 + j] = 0;
				}
			return;
		}
		if (endstage == 0) {
			bool vis[52] = { false };
			int c1 = mycard / 52, c2 = mycard % 52;
			vis[c1] = vis[c2] = true;
			for (int i = 0; i < total_cards; i++) {
				for (int j = i + 1; j < total_cards; j++) {
					int cnt = i * 52 + j;
					if (vis[i] || vis[j] || range[cnt] == 0) {
						actionicfvs1[cnt] = 0;
						continue;
					}
					double winrate = preflop_allin[c1 * 52 + c2][i * 52 + j] / (double)preflop_allin_divde;	//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
					actionicfvs1[cnt] = state.table.total_pot / 2 * winrate;//期望赢得筹码-投入的筹码 = 期望收益
					assert(actionicfvs1[cnt] < 20001);
				}
			}
		}
		else if (endstage == 1) {
			bool vis[52] = { false };
			int c1 = mycard / 52, c2 = mycard % 52;
			vis[c1] = vis[c2] = vis[communitycards[0]] = vis[communitycards[1]] = vis[communitycards[2]] = true;
			for (int i = 0; i < total_cards; i++) {
				for (int j = i + 1; j < total_cards; j++) {
					int cnt = i * 52 + j;
					if (vis[i] || vis[j] || range[cnt] <= 0) {
						actionicfvs1[cnt] = 0;
						continue;
					}
					vis[i] = vis[j] = true;

					int id0 = 0, id1 = 0, id2 = 0;
					for (int t1 = 0; t1 < total_cards; t1++) {
						if (!vis[t1])
							for (int t2 = t1 + 1; t2 < total_cards; t2++)
								if (!vis[t2]){
									int strength1 = engine->find_strength((1ll << c1) + (1ll << c2) + (1ll << communitycards[0]) + (1ll << communitycards[1]) + (1ll << communitycards[2]) + (1ll << t1) + (1ll << t2));
									int strength2 = engine->find_strength((1ll << i) + (1ll << j) + (1ll << communitycards[0]) + (1ll << communitycards[1]) + (1ll << communitycards[2]) + (1ll << t1) + (1ll << t2));
									if (strength1 > strength2)
										id0++;
									else if (strength1 < strength2)
										id1++;
									else
										id2++;
								}
					}
					vis[i] = vis[j] = false;
					assert(id0 + id1 + id2 == 990);
					double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);	//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
					actionicfvs1[cnt] = (0.5 - winrate) * state.table.total_pot;//期望赢得筹码-投入的筹码 = 期望收益
				}
			}
		}
		else if (endstage == 2) {
			bool vis[52] = { false };
			int c1 = mycard / 52, c2 = mycard % 52;
			vis[c1] = vis[c2] = vis[communitycards[0]] = vis[communitycards[1]] = vis[communitycards[2]] = vis[communitycards[3]] = true;
			for (int i = 0; i < total_cards; i++) {
				for (int j = i + 1; j < total_cards; j++) {
					int cnt = i * 52 + j;
					if (vis[i] || vis[j] || range[cnt] <= 0) {
						actionicfvs1[cnt] = 0;
						continue;
					}
					vis[i] = vis[j] = true;
					int id0 = 0, id1 = 0, id2 = 0;
					for (int t1 = 0; t1 < total_cards; t1++) {
						if (!vis[t1]){
							int strength1 = engine->find_strength((1ll << c1) + (1ll << c2) + (1ll << communitycards[0]) + (1ll << communitycards[1]) + (1ll << communitycards[2]) + (1ll << communitycards[3]) + (1ll << t1));
							int strength2 = engine->find_strength((1ll << i) + (1ll << j) + (1ll << communitycards[0]) + (1ll << communitycards[1]) + (1ll << communitycards[2]) + (1ll << communitycards[3]) + (1ll << t1));
							if (strength1 > strength2)
								id0++;
							else if (strength1 < strength2)
								id1++;
							else
								id2++;
						}
					}
					vis[i] = vis[j] = false;
					assert(id0 + id1 + id2 == 44);
					double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);	//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
					actionicfvs1[cnt] = (0.5 - winrate) * state.table.total_pot;//期望赢得筹码-投入的筹码 = 期望收益
				}
			}
		}
		else {
			int c1 = mycard / 52, c2 = mycard % 52;
			int strength1 = engine->find_strength((1ll << c1) + (1ll << c2) + (1ll << communitycards[0]) + (1ll << communitycards[1]) + (1ll << communitycards[2]) + (1ll << communitycards[3]) + (1ll << communitycards[4]));
			for (int i = 0; i < total_cards; i++) {
				for (int j = i + 1; j < total_cards; j++) {
					int cnt = i * 52 + j;
					if (range[cnt] > 0) {
						int strength2 = engine->find_strength((1ll << i) + (1ll << j) + (1ll << communitycards[0]) + (1ll << communitycards[1]) + (1ll << communitycards[2]) + (1ll << communitycards[3]) + (1ll << communitycards[4]));
						if (strength1 > strength2)
							actionicfvs1[cnt] = -state.table.total_pot * 0.5;
						else if (strength1 < strength2)
							actionicfvs1[cnt] = state.table.total_pot * 0.5;
						else
							actionicfvs1[cnt] = 0;
					}
					else
						actionicfvs1[cnt] = 0;
				}
			}
		}
		return;
	}
	int ph = state.player_i_index;
	strategy_node* tempprivatenode[2652];
	unsigned char lactions[12];
	int laction_len = state.legal_actions(lactions);
	assert(laction_len != 0);
	double cfv[4][2652];
	memset(cfv, 0, sizeof cfv);
	for (int f = 0; f < laction_len; f++) {
		Pokerstate newstate = state;
		bool is_chance = newstate.take_action(lactions[f]);
		double newrange[2652];
		if (state.player_i_index != expoliti) {
			for (int g = 0; g < total_cards; g++)
				for (int h = g + 1; h < total_cards; h++) {
					int cnt = g * 52 + h;
					if (range[cnt] > 0) {
						double tmp = calculate_strategy(privatenode[cnt]->averegret, privatenode[cnt]->action_len, f);
						newrange[cnt] = range[cnt] * tmp;
					}
					else
						newrange[cnt] = 0;
				}
		}
		else {
			for (int g = 0; g < total_cards; g++)
				for (int h = g + 1; h < total_cards; h++) {
					int cnt = g * 52 + h;
					newrange[cnt] = range[cnt];
				}
		}
		if (is_chance) {
			double temprange[2652];
			double tempactionicfv1[2652];
			bool vis[52] = { false };
			vis[mycard / 52] = vis[mycard % 52] = true;
			int testadd[2652];
			memset(testadd, 0, sizeof testadd);
			if (newstate.betting_stage == 1) {
				unsigned char excludecard[2];
				excludecard[0] = mycard / 52;
				excludecard[1] = mycard % 52;
				int count = 0;
				for (int k = 0; k < 500; k++) {
					state.table.deck.reset(excludecard, 2);
					int t1 = state.table.deck.deal_one_card();
					int t2 = state.table.deck.deal_one_card();
					int t3 = state.table.deck.deal_one_card();
					{
						vis[t1] = vis[t2] = vis[t3] = true;
						count++;
						memset(temprange, 0, sizeof(temprange));
						double tot = 0;
						for (int g = 0; g < total_cards; g++)
							for (int h = g + 1; h < total_cards; h++) {
								int cnt = g * 52 + h;
								if (!vis[g] && !vis[h] && newrange[cnt] > 0) {
									temprange[cnt] = newrange[cnt];
									tot += newrange[cnt];
									unsigned char coms[] = { t1, t2 , t3 };
									int ck = engine->get_flop_cluster(g, h, coms);
									tempprivatenode[cnt] = privatenode[cnt]->actions[f].actions + ck;
								}
							}
						vis[t1] = vis[t2] = vis[t3] = false;
						communitycards[0] = t1;
						communitycards[1] = t2;
						communitycards[2] = t3;
						getnode_cfv_holdem(tempprivatenode, newstate, temprange, tempactionicfv1, communitycards, expoliti, mycard, endstage + 1);
						for (int g = 0; g < total_cards; g++)
							for (int h = g + 1; h < total_cards; h++) {
								int cnt = g * 52 + h;
								if (temprange[cnt] > 0)
									cfv[f][cnt] += tempactionicfv1[cnt], testadd[cnt]++;
							}
					}
				}
				assert(count == 500);
				for (int g = 0; g < total_cards; g++)
					for (int h = g + 1; h < total_cards; h++) {
						int cnt = g * 52 + h;
						if (newrange[cnt] > 0 && testadd[cnt] > 0)
							cfv[f][cnt] /= testadd[cnt];
					}
			}
			else if (newstate.betting_stage == 2) {
				int count = 0;
				vis[communitycards[0]] = vis[communitycards[1]] = vis[communitycards[2]] = true;
				for (int t1 = 0; t1 < total_cards; t1++) {
					if (!vis[t1]) {
						vis[t1] = true;
						count++;
						memset(temprange, 0, sizeof(temprange));
						double tot = 0;
						for (int g = 0; g < total_cards; g++)
							for (int h = g + 1; h < total_cards; h++) {
								int cnt = g * 52 + h;
								if (!vis[g] && !vis[h] && newrange[cnt] > 0) {
									temprange[cnt] = newrange[cnt];
									tot += newrange[cnt];
									unsigned char coms[] = { communitycards[0], communitycards[1], communitycards[2], t1 };
									int ck = engine->get_turn_cluster(g, h,coms);
									tempprivatenode[cnt] = privatenode[cnt]->actions[f].actions + ck;
								}
							}
						vis[t1] = false;
						communitycards[3] = t1;
						getnode_cfv_holdem(tempprivatenode, newstate, temprange, tempactionicfv1, communitycards, expoliti, mycard, endstage + 1);
						for (int g = 0; g < total_cards; g++)
							for (int h = g + 1; h < total_cards; h++) {
								int cnt = g * 52 + h;
								if (temprange[cnt] > 0)
									cfv[f][cnt] += tempactionicfv1[cnt], testadd[cnt]++;
							}
					}
				}
				assert(count == 47);
				for (int g = 0; g < total_cards; g++)
					for (int h = g + 1; h < total_cards; h++) {
						int cnt = g * 52 + h;
						if (newrange[cnt] > 0)
							cfv[f][cnt] /= 45, assert(testadd[cnt] == 45);
					}
			}
			else if (newstate.betting_stage == 3) {
				int count = 0;
				vis[communitycards[0]] = vis[communitycards[1]] = vis[communitycards[2]] = vis[communitycards[3]] = true;
				for (int t1 = 0; t1 < total_cards; t1++) {
					if (!vis[t1]) {
						vis[t1] = true;
						count++;
						memset(temprange, 0, sizeof(temprange));
						double tot = 0;
						for (int g = 0; g < total_cards; g++)
							for (int h = g + 1; h < total_cards; h++) {
								int cnt = g * 52 + h;
								if (!vis[g] && !vis[h] && newrange[cnt] > 0) {
									temprange[cnt] = newrange[cnt];
									tot += newrange[cnt];
									unsigned char coms[] = { communitycards[0], communitycards[1], communitycards[2], communitycards[3], t1 };
									int ck = engine->get_river_cluster(g, h, coms);
									tempprivatenode[cnt] = privatenode[cnt]->actions[f].actions + ck;
								}
							}
						vis[t1] = false;
						communitycards[4] = t1;
						getnode_cfv_holdem(tempprivatenode, newstate, temprange, tempactionicfv1, communitycards, expoliti, mycard, endstage + 1);
						for (int g = 0; g < total_cards; g++)
							for (int h = g + 1; h < total_cards; h++) {
								int cnt = g * 52 + h;
								if (temprange[cnt] > 0)
									cfv[f][cnt] += tempactionicfv1[cnt], testadd[cnt]++;
							}
					}
				}
				assert(count == 46);
				for (int g = 0; g < total_cards; g++)
					for (int h = g + 1; h < total_cards; h++){
						int cnt = g * 52 + h;
						if (newrange[cnt] > 0)
							cfv[f][cnt] /= 44, assert(testadd[cnt] == 44);
					}
			}
		}
		else {
			for (int g = 0; g < total_cards; g++)
				for (int h = g + 1; h < total_cards; h++) {
					int cnt = g * 52 + h;
					if (newrange[cnt] > 0)
						tempprivatenode[cnt] = privatenode[cnt]->actions + f;
				}
			getnode_cfv_holdem(tempprivatenode, newstate, newrange, cfv[f], communitycards, expoliti, mycard, endstage);
		}
	}
	if (state.player_i_index == expoliti) {
		double cfvs[12];
		int selfc = expoliti ^ 1;
		memset(cfvs, 0, sizeof cfvs);
		double ans = 0;
		for (int g = 0; g < total_cards; g++)
			for (int h = g + 1; h < total_cards; h++) {
				int cnt = g * 52 + h;
				if (range[cnt] > 0)
					ans += range[cnt];
			}
		for (int g = 0; g < total_cards; g++)
			for (int h = g + 1; h < total_cards; h++) {
				int cnt = g * 52 + h;
				if (range[cnt] > 0) {
					double temp = range[cnt] / ans;
					for (int k = 0; k < privatenode[cnt]->action_len; k++)
						cfvs[k] += temp * cfv[k][cnt];
				}
			}
		int index = 0;
		for (int k = 1; k < laction_len; k++)
			if (cfvs[index] < cfvs[k])
				index = k;
		for (int g = 0; g < total_cards; g++)
			for (int h = g + 1; h < total_cards; h++) {
				int cnt = g * 52 + h;
				actionicfvs1[cnt] = cfv[index][cnt];
				assert(actionicfvs1[cnt] < 20001);
			}
	}
	else
		for (int g = 0; g < total_cards; g++)
			for (int h = g + 1; h < total_cards; h++) {
				int cnt = g * 52 + h;
				if (range[cnt] > 0) {
					double sigma[12];
					calculate_strategy(privatenode[cnt]->averegret, privatenode[cnt]->action_len, sigma);
					double val = 0;
					for (int i = 0; i < privatenode[cnt]->action_len; i++)
						val += cfv[i][cnt] * sigma[i];
					actionicfvs1[cnt] = val;
				}
				else
					actionicfvs1[cnt] = 0;
				assert(actionicfvs1[cnt] < 20001);
			}
}
void thread_cfv_holdem(strategy_node* privatenode[2652], double range[2652], Pokerstate state, int expoliti, int mycard, double* exploitval) {
	double actionicfvs1[2652];
	bool vis[52] = { false };
	int c1 = mycard / 52, c2 = mycard % 52;
	int tot = 0;
	vis[c1] = vis[c2] = true;
	double ranget[2652];
	memset(ranget, 0, sizeof ranget);
	for (int i = 0; i < total_cards; i++) {
		for (int j = i + 1; j < total_cards; j++) {
			if (!vis[i] && !vis[j] && range[i * 52 + j] > 0) {
				int cnt = i * 52 + j;
				assert(range[cnt] == 1);
				assert(ranget[cnt] == 0);
				ranget[cnt] = range[cnt];
				tot += ranget[cnt];
			}
		}
	}
	assert(tot == 1225);
	unsigned char communitycard[5];
	struct timeval start, end;
	gettimeofday(&start, NULL);
	getnode_cfv_holdem(privatenode, state, ranget, actionicfvs1, communitycard, expoliti, mycard, 0);
	gettimeofday(&end, NULL);
	cout << "mycard :" << mycard / 52 << "," << mycard % 52 << "," << ((end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec)) / 1000000.0 << endl;
	for (int i = 0; i < total_cards; i++)
		for (int j = i + 1; j < total_cards; j++) {
			int cnt = i * 52 + j;
			if (ranget[cnt] > 0)
				*exploitval += ranget[cnt] * actionicfvs1[cnt];
		}
	*exploitval /= tot;
	return;
}
double getcfv_whole_holdem(strategy_node* privateroot, Pokerstate state, int exi) {
	strategy_node* privatenode[2652];
	double range[2652];
	int exirange[169];
	memset(range, 0, sizeof range);
	memset(exirange, 0, sizeof exirange);
	for (int i = 0; i < total_cards; i++)
		for (int j = i + 1; j < total_cards; j++) {
			privatenode[i * 52 + j] = privateroot->actions + engine->get_preflop_cluster(i, j);
			range[i * 52 + j] = 1;
			exirange[engine->get_preflop_cluster(i, j)]++;
		}

	double exploitval[2652];
	memset(exploitval, 0, sizeof exploitval);
	double normv = 0;
	bool visc[169] = { false };
	mutex mtx1;
	std::unique_lock<mutex> lck(cfvmtx);
	for (int i = 0; i < total_cards; i++) {
		for (int j = i + 1; j < total_cards; j++){
			int tp = engine->get_preflop_cluster(i, j);
			if (!visc[tp]) {
				visc[tp] = true;
				cfvpool.commit(thread_cfv_holdem, privatenode, range, state, exi, i * 52 + j, &exploitval[tp]);
				//thread_cfv_holdem(privatenode, range, state, exi, i * 52 + j, &exploitval[tp]);
			}
		}
	}
	cfvdumpwait.wait(lck);
	while (cfvpool.acttaskNum.load() != 0)
		sleep(1);
	double ans = 0;
	for (int i = 0; i < 169; i++) 
		ans += exirange[i] * exploitval[i];
		
	return ans / (total_cards * (total_cards - 1) / 2);
}
